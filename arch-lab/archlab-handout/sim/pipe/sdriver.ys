#######################################################################
# Test for copying block of size 4;
#######################################################################
	.pos 0
main:	irmovq Stack, %rsp  	# Set up stack pointer

	# Set up arguments for copy function and then invoke it
	irmovq $4, %rdx		# src and dst have 4 elements
	irmovq dest, %rsi	# dst array
	irmovq src, %rdi	# src array
	call ncopy		 
	halt			# should halt with num nonzeros in %rax
StartFun:
# 1. Add instruction `iaddq` and replace `irmovq` followed by `subq` or `addq` to it.
# 2. Use loop unrolling and search the remainder by binary search
# 3. Use interleaving to resolve data hazard.
#/* $begin ncopy-ys */
##################################################################
# ncopy.ys - Copy a src block of len words to dst.
# Return the number of positive words (>0) contained in src.
#
# Include your name and ID here.
#
# Describe how and why you modified the baseline code.
#
##################################################################
# Do not modify this portion
# Function prologue.
# %rdi = src, %rsi = dst, %rdx = len
ncopy:
  xorq %rax, %rax # count = 0
  iaddq $-8, %rdx
  jl handle_remainder # 0 < len < 8
loop:
  mrmovq (%rdi), %rcx
copy_and_check_1st:
  mrmovq 0x8(%rdi), %r8
  rmmovq %rcx, (%rsi)
# if the 1st value > 0?
  andq %rcx, %rcx
  jle copy_and_check_2nd
  iaddq $1, %rax
copy_and_check_2nd:
  mrmovq 0x10(%rdi), %r9
  rmmovq %r8, 0x8(%rsi)
# if the 2nd value > 0?
  andq %r8, %r8
  jle copy_and_check_3rd
  iaddq $1, %rax
copy_and_check_3rd:
  mrmovq 0x18(%rdi), %r10
  rmmovq %r9, 0x10(%rsi)
# if the 3rd value > 0?
  andq %r9, %r9
  jle copy_and_check_4th
  iaddq $1, %rax
copy_and_check_4th:
  mrmovq 0x20(%rdi), %r11
  rmmovq %r10, 0x18(%rsi)
# if the 4th value > 0?
  andq %r10, %r10
  jle copy_and_check_5th
  iaddq $1, %rax
copy_and_check_5th:
  mrmovq 0x28(%rdi), %r12
  rmmovq %r11, 0x20(%rsi)
# if the 5th value > 0?
  andq %r11, %r11
  jle copy_and_check_6th
  iaddq $1, %rax
copy_and_check_6th:
  mrmovq 0x30(%rdi), %r13
  rmmovq %r12, 0x28(%rsi)
# if the 6th value > 0?
  andq %r12, %r12
  jle copy_and_check_7th
  iaddq $1, %rax
copy_and_check_7th:
  mrmovq 0x38(%rdi), %r14
  rmmovq %r13, 0x30(%rsi)
# if the 7th value > 0?
  andq %r13, %r13
  jle copy_and_check_8th
  iaddq $1, %rax
copy_and_check_8th:
  rmmovq %r14, 0x38(%rsi)
# if the 8th value > 0?
  andq %r14, %r14
  jle npos
  iaddq $1, %rax
npos:
  iaddq $64, %rdi
  iaddq $64, %rsi
  iaddq $-8, %rdx
  jge loop
# rdx range from -8 to -1
handle_remainder:
  iaddq $4, %rdx
  jl remainder_0_3
# rdx >= -4 -> rdx+8 >= 4 -> remainder is [4,7]
remainder_4_7:
  iaddq $-2, %rdx
  jl remainder_4_5
# rdx+4 >= 2 -> rdx+8 >= 6 -> remainder is [6,7]
remainder_6_7:
  iaddq $-1, %rdx
# rdx+2 < 1 -> rdx+8 < 7 -> remainder is 6
  mrmovq 40(%rdi), %rbx
  jl remainder_6
# rdx+2 >= 1 -> rdx+8 >= 7 -> remainder is 7
  mrmovq 48(%rdi), %rbx
  jmp remainder_7
# rdx < -4 -> rdx+8 < 4 -> remainder is [0,3]
remainder_0_3:
  iaddq $2, %rdx
  jl remainder_0_1
# rdx+4 >= -2 -> rdx+8 >= 2 -> remainder is [2,3]
remainder_2_3:
  iaddq $-1, %rdx
# rdx+6 < 1 -> rdx+8 < 3 -> remainder is 2
  mrmovq 8(%rdi), %rbx
  jl remainder_2
# rdx+6 >= 1 -> rdx+8 >= 3 -> remainder is 3
  mrmovq 16(%rdi), %rbx
  jmp remainder_3
# rdx+4 < -2 -> rdx+8 < 2 -> remainder is [0,1]
remainder_0_1:
  iaddq $1, %rdx
# rdx+6 < -1 -> rdx+8 < 1 -> remainder is 0
  jl Done
# rdx+6 >= -1 -> rdx+8 >= 1 -> remainder is 1
  mrmovq (%rdi), %rbx
  jmp remainder_1
# rdx+4 < 2 -> rdx+8 < 6 -> remainder is [4,5]
remainder_4_5:
  iaddq $1, %rdx
# rdx+2 < -1 -> rdx+8 < 5 -> remainder is 4
  mrmovq 24(%rdi), %rbx
  jl remainder_4
# rdx+2 >= -1 -> rdx+8 >= 5 -> remainder is 5
  mrmovq 32(%rdi), %rbx
  jmp remainder_5
remainder_7:
  rmmovq %rbx, 48(%rsi)
  andq %rbx, %rbx
  mrmovq 40(%rdi), %rbx
  jle remainder_6
  iaddq $1, %rax
remainder_6:
  rmmovq %rbx, 40(%rsi)
  andq %rbx, %rbx
  mrmovq 32(%rdi), %rbx
  jle remainder_5
  iaddq $1, %rax
remainder_5:
  rmmovq %rbx, 32(%rsi)
  andq %rbx, %rbx
  mrmovq 24(%rdi), %rbx
  jle remainder_4
  iaddq $1, %rax
remainder_4:
  rmmovq %rbx, 24(%rsi)
  andq %rbx, %rbx
  mrmovq 16(%rdi), %rbx
  jle remainder_3
  iaddq $1, %rax
remainder_3:
  rmmovq %rbx, 16(%rsi)
  andq %rbx, %rbx
  mrmovq 8(%rdi), %rbx
  jle remainder_2
  iaddq $1, %rax
remainder_2:
  rmmovq %rbx, 8(%rsi)
  andq %rbx, %rbx
  mrmovq (%rdi), %rbx
  jle remainder_1
  iaddq $1, %rax
remainder_1:
  rmmovq %rbx, (%rsi)
  andq %rbx, %rbx
  jle Done
  iaddq $1, %rax
Done:
	ret
##################################################################
# Keep the following label at the end of your function
End:
#/* $end ncopy-ys */
EndFun:

###############################
# Source and destination blocks 
###############################
	.align 8
src:
	.quad -1
	.quad 2
	.quad -3
	.quad 4
	.quad 0xbcdefa # This shouldn't get moved

	.align 16
Predest:
	.quad 0xbcdefa
dest:
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
Postdest:
	.quad 0xdefabc

.align 8
# Run time stack
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0

Stack:
